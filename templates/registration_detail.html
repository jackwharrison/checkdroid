{% extends "base.html" %}
{% block title %}Registration – CheckDroid{% endblock %}

{% block content %}

<div class="reg-detail-page"
     data-program-id="{{ program_id }}"
     data-registration-id="{{ registration_id }}">

  <div class="reg-detail-card">

        <button type="button"
                class="reg-back-link"
                id="backToProgramBtn">
        ← Back to program
        </button>

    <header class="reg-detail-header">
      <div>
        <div id="regTitle" class="reg-detail-title">
          Edit: Registration #{{ registration_id }}
        </div>
        <span id="regStatusBadge" class="reg-status-badge reg-status-new">
          New
        </span>
      </div>

      <button type="button"
              id="regEditBtn"
              class="btn btn-secondary reg-edit-btn">
        ✏️ Edit
      </button>
    </header>

    <form id="regEditForm" class="reg-form" novalidate>
      <div id="regDetailError" class="reg-error" hidden></div>

      <!-- dynamic grid – fields are injected by JS -->
      <div id="dynamicFields" class="reg-form-grid"></div>

      <div class="reg-detail-actions">
        <button type="button"
                id="editCancelBtn"
                class="btn btn-secondary reg-cancel-btn">
          Cancel
        </button>
        <button type="submit"
                id="editSaveBtn"
                class="btn btn-primary reg-save-btn">
          Next
        </button>
      </div>
    </form>
  </div>
</div>

<script>
(function () {
  const DB_NAME    = 'checkdroid';
  const DB_VERSION = 3;              // keep in sync with validate page (outbox added)
  const REG_STORE  = 'registrations';

  // where we stash the review payload for the next page
  const REVIEW_KEY = 'checkdroid_review_payload';

  const root = document.querySelector('.reg-detail-page');
  if (!root) return;

  // ---------- helpers (must exist before use) ----------
  function showError(msg) {
    const errorEl = document.getElementById('regDetailError');
    if (!errorEl) return;
    errorEl.textContent = msg;
    errorEl.hidden = false;
  }

  function escapeHtml(str) {
    return String(str ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function labelFromKey(key) {
    return key
      .replace(/_/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .replace(/\s+/g, ' ')
      .trim()
      .replace(/^./, c => c.toUpperCase());
  }

  // ---------- resolve IDs (online render OR offline shell) ----------
  function parseIdsFromPath() {
    // expects /registration/<programId>/<registrationId>
    const parts = window.location.pathname.split('/').filter(Boolean);
    const i = parts.indexOf('registration');
    if (i === -1 || parts.length < i + 3) return { programId: null, registrationId: null };

    return {
      programId: parseInt(parts[i + 1], 10) || null,
      registrationId: parseInt(parts[i + 2], 10) || null,
    };
  }

  const fromUrl = parseIdsFromPath();

  const datasetProgramId =
    parseInt(root.dataset.programId || '', 10) || fromUrl.programId;

  const regId =
    parseInt(root.dataset.registrationId || '', 10) || fromUrl.registrationId;

  if (!datasetProgramId || !regId) {
    showError('Missing program/registration ID in the URL. Please sync online first, then retry offline.');
    return;
  }

  // keep dataset consistent for downstream code
  root.dataset.programId = String(datasetProgramId);
  root.dataset.registrationId = String(regId);

  // ---------- DOM ----------
  const titleEl      = document.getElementById('regTitle');
  const statusBadge  = document.getElementById('regStatusBadge');
  const editBtn      = document.getElementById('regEditBtn');
  const form         = document.getElementById('regEditForm');
  const fieldsWrap   = document.getElementById('dynamicFields');
  const errorEl      = document.getElementById('regDetailError');
  const cancelBtn    = document.getElementById('editCancelBtn');
  const saveBtn      = document.getElementById('editSaveBtn');
  const backBtn      = document.getElementById('backToProgramBtn');

  if (backBtn) {
    backBtn.addEventListener('click', () => {
      window.location.href = `/validate?program_id=${encodeURIComponent(datasetProgramId)}`;
    });
  }

  let originalReg   = null;
  let referenceId   = null;
  let editableKeys  = [];
  let fieldTypes    = {};
  let mode          = 'view';

  // fields we NEVER show/edit
  const NON_EDITABLE_KEYS = [
    'id',
    'programId',
    'referenceId',
    'status',
    'created',
    'registrationProgramId',
    'lastMessageStatus',
    'paymentCount',
    'paymentCountRemaining',
    'scope',
    'duplicateStatus',
    'programFspConfigurationId',
    'programFspConfigurationName',
    'programFspConfigurationLabel',
    'fspName',
    'paymentAmountMultiplier',
    'maxPayments',
    'personAffectedSequence',
    'inclusionScore',
    // any local-only fields you may add
    'validatedAt',
    'validatedOnDevice',
  ];

  // ---------- IndexedDB ----------
  function openDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onsuccess = () => resolve(req.result);
      req.onerror   = () => reject(req.error);
    });
  }

  function loadRegistration(db) {
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(REG_STORE, 'readonly');
      const store = tx.objectStore(REG_STORE);
      const req   = store.get(regId);
      req.onsuccess = () => resolve(req.result || null);
      req.onerror   = () => reject(req.error);
    });
  }

  // ---------- UI ----------
  function setMode(newMode) {
    mode = newMode;
    const editable = (newMode === 'edit');

    // disable/enable fields
    for (const el of form.querySelectorAll('input, select, textarea')) {
      el.disabled = !editable;
    }

    if (editable) {
      root.classList.add('editing');
      if (errorEl) errorEl.hidden = true;
      if (saveBtn) saveBtn.disabled = false;
    } else {
      root.classList.remove('editing');
    }
  }

  function buildDynamicFields(reg) {
    fieldsWrap.innerHTML = '';
    editableKeys = [];
    fieldTypes   = {};

    Object.keys(reg).forEach(key => {
      if (NON_EDITABLE_KEYS.includes(key)) return;

      const val = reg[key];
      if (val !== null && typeof val === 'object') return; // skip nested objects/arrays

      editableKeys.push(key);
      fieldTypes[key] = (val === null || val === undefined) ? 'string' : typeof val;
    });

    editableKeys.sort();

    for (const key of editableKeys) {
      const val   = reg[key];
      const label = labelFromKey(key);
      const id    = `field-${key}`;

      const fieldDiv = document.createElement('div');
      fieldDiv.className = 'reg-form-field';
      fieldDiv.innerHTML = `
        <label for="${id}">${escapeHtml(label)}</label>
        <input
          id="${id}"
          name="${key}"
          type="text"
          value="${escapeHtml(val ?? '')}"
        >
      `;
      fieldsWrap.appendChild(fieldDiv);
    }
  }

  function fillForm(reg) {
    referenceId = reg.referenceId;

    if (titleEl) titleEl.textContent = `Edit: Registration #${reg.id}`;

    const status = String(reg.status || 'new').toLowerCase();
    if (statusBadge) {
      statusBadge.textContent = (status === 'validated') ? 'Validated' : 'New';
      statusBadge.className =
        'reg-status-badge ' +
        ((status === 'validated') ? 'reg-status-validated' : 'reg-status-new');
    }

    buildDynamicFields(reg);
  }

  // ---------- submit helpers ----------
  function collectUpdates() {
    const updates = {};

    for (const key of editableKeys) {
      const input = form.elements[key];
      if (!input) continue;

      const raw  = input.value;
      const type = fieldTypes[key];

      let newVal;

      if (type === 'number') {
        const trimmed = (raw || '').trim();
        newVal = trimmed === '' ? null : Number(trimmed);
        if (Number.isNaN(newVal)) newVal = null;
      } else {
        const trimmed = (raw || '').trim();
        newVal = trimmed === '' ? null : trimmed;
      }

      const oldVal = originalReg[key];

      const normOld =
        oldVal === null || oldVal === undefined ? '' : String(oldVal).trim();

      const normNew =
        newVal === null || newVal === undefined ? '' : String(newVal).trim();

      if (normNew !== normOld) {
        updates[key] = newVal;
      }
    }

    return updates;
  }

  // ---------- init ----------
  openDb()
    .then(loadRegistration)
    .then(reg => {
      if (!reg) {
        showError('Could not find this registration in the offline cache.');
        return;
      }

      originalReg = reg;
      fillForm(reg);
      setMode('view');

      if (editBtn) {
        editBtn.addEventListener('click', (e) => {
          e.preventDefault();
          setMode('edit');
        });
      }

      if (cancelBtn) {
        cancelBtn.addEventListener('click', (e) => {
          e.preventDefault();
          if (originalReg) fillForm(originalReg);
          setMode('view');
        });
      }

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (errorEl) errorEl.hidden = true;

        if (!referenceId) {
          showError('Missing reference ID for this registration.');
          return;
        }

        const programId = originalReg.programId || datasetProgramId;
        if (!programId) {
          showError('Missing programId for this registration.');
          return;
        }

        const updates = collectUpdates();

        // Build payload for review page
        const reviewPayload = {
          programId: programId,
          registrationId: originalReg.id,
          referenceId: referenceId,
          updates: updates,        // may be empty
          original: originalReg,   // used for diff
        };

        try {
          sessionStorage.setItem(REVIEW_KEY, JSON.stringify(reviewPayload));
        } catch (err) {
          console.error('Failed to store review payload in sessionStorage', err);
          showError('Unable to prepare review. Please try again.');
          return;
        }

        // Go to review page (supports offline shell via querystring)
        const url =
          `/validate/review?program_id=${encodeURIComponent(programId)}` +
          `&registration_id=${encodeURIComponent(originalReg.id)}`;
        window.location.href = url;
      });
    })
    .catch(err => {
      console.error('Failed to load registration detail', err);
      showError('Could not load this registration.');
    });
})();
</script>

{% endblock %}
