{% extends "base.html" %}
{% block title %}Review changes – CheckDroid{% endblock %}

{% block content %}

<div class="review-page"
     data-program-id="{{ program_id }}"
     data-registration-id="{{ registration_id }}">

  <div class="review-card">

    <button type="button"
            class="reg-back-link"
            id="reviewBackBtn">
      ← Back to editing
    </button>

    <header class="review-header">
      <div>
        <!-- give the title an ID so we can change it when there are no changes -->
        <h1 id="reviewTitle" class="review-title">Review changes</h1>
        <div id="reviewSubtitle"
             class="review-subtitle">
          Registration #{{ registration_id }}
        </div>
      </div>
    </header>

    <section class="review-changes">
      <!-- also give these IDs so we can tweak copy dynamically -->
      <h2 id="reviewSectionTitle" class="review-section-title">Changes to this registration</h2>
      <p id="reviewHelper" class="review-helper">Please review edited fields:</p>
      <div id="changesEmpty" class="muted small" hidden>
        No field changes – you are only providing a reason.
      </div>

      <table class="review-table" id="changesTable">
        <thead>
          <tr>
            <th>Field</th>
            <th>Before</th>
            <th>After</th>
          </tr>
        </thead>
        <tbody id="changesBody">
          <!-- rows injected by JS -->
        </tbody>
      </table>
    </section>

    <form id="reviewForm" class="review-form" novalidate>
      <div id="reviewError" class="reg-error" hidden></div>

      <!-- WRAPPER NOW HAS AN ID SO WE CAN HIDE IT WHEN NO CHANGES -->
      <div id="reasonFieldWrap" class="reg-form-field">
        <label for="reason">Provide a reason for these changes*</label>
        <textarea id="reason"
                  name="reason"
                  maxlength="500"
                  rows="3"></textarea>
        <div id="reasonCounter" class="muted small"></div>
      </div>

      <div class="review-actions">
        <button type="button"
                class="btn btn-secondary"
                id="reviewCancelBtn">
          Cancel
        </button>
        <button type="submit"
                class="btn btn-primary"
                id="reviewSubmitBtn">
          Save and validate
        </button>
      </div>
    </form>
  </div>
</div>

<script>
(function () {
  const DB_NAME    = 'checkdroid';
  const DB_VERSION = 3; // <-- bump to match validate.html + include outbox store
  const REG_STORE  = 'registrations';
  const OUTBOX_STORE = 'outbox';

  const REVIEW_KEY = 'checkdroid_review_payload';

  const root = document.querySelector('.review-page');
  if (!root) return;

  // ---------- Helpers used early ----------
  const reviewError  = document.getElementById('reviewError');
  function showError(msg) {
    if (!reviewError) return;
    reviewError.textContent = msg;
    reviewError.hidden = false;
  }

  function parseIdsFromQueryOrDom(rootEl) {
    const dsPid = parseInt(rootEl?.dataset?.programId || '', 10) || null;
    const dsRid = parseInt(rootEl?.dataset?.registrationId || '', 10) || null;

    const qs = new URLSearchParams(window.location.search);
    const qsPid = parseInt(qs.get('program_id') || '', 10) || null;
    const qsRid = parseInt(qs.get('registration_id') || '', 10) || null;

    return {
      programId: dsPid || qsPid,
      registrationId: dsRid || qsRid,
    };
  }

  const ids = parseIdsFromQueryOrDom(root);
  const programId = ids.programId;
  const registrationId = ids.registrationId;

  if (!programId || !registrationId) {
    showError('Missing program/registration ID. Please go back and open the review step again.');
    return;
  }

  root.dataset.programId = String(programId);
  root.dataset.registrationId = String(registrationId);

  const backBtn      = document.getElementById('reviewBackBtn');
  const changesTable = document.getElementById('changesTable');
  const changesBody  = document.getElementById('changesBody');
  const changesEmpty = document.getElementById('changesEmpty');
  const reviewForm   = document.getElementById('reviewForm');
  const reasonInput  = document.getElementById('reason');
  const cancelBtn    = document.getElementById('reviewCancelBtn');
  const submitBtn    = document.getElementById('reviewSubmitBtn');
  const subtitleEl   = document.getElementById('reviewSubtitle');
  const counterEl    = document.getElementById('reasonCounter');
  const reasonFieldWrap = document.getElementById('reasonFieldWrap');

  const pageTitleEl       = document.getElementById('reviewTitle');
  const sectionTitleEl    = document.getElementById('reviewSectionTitle');
  const sectionHelperEl   = document.getElementById('reviewHelper');

  let payload = null;
  let hasFieldChanges = false;

  function escapeHtml(str) {
    return String(str ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function labelFromKey(key) {
    return key
      .replace(/_/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .replace(/\s+/g, ' ')
      .trim()
      .replace(/^./, c => c.toUpperCase());
  }

  // ---------- IndexedDB helpers ----------
  function openDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);

      // In case validate page hasn't upgraded DB yet, ensure outbox exists here too
      req.onupgradeneeded = (event) => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains(REG_STORE)) {
          const regStore = db.createObjectStore(REG_STORE, { keyPath: 'id' });
          regStore.createIndex('by_program', 'programId', { unique: false });
        }

        if (!db.objectStoreNames.contains(OUTBOX_STORE)) {
          const out = db.createObjectStore(OUTBOX_STORE, { keyPath: 'id' });
          out.createIndex('by_status', 'status', { unique: false });
          out.createIndex('by_created', 'createdAt', { unique: false });
          out.createIndex('by_reg', 'registrationId', { unique: false });
          out.createIndex('by_program', 'programId', { unique: false });
        }
      };

      req.onsuccess = () => resolve(req.result);
      req.onerror   = () => reject(req.error);
    });
  }

  function loadRegistration(db) {
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(REG_STORE, 'readonly');
      const store = tx.objectStore(REG_STORE);
      const req   = store.get(registrationId);

      req.onsuccess = () => resolve(req.result || null);
      req.onerror   = () => reject(req.error);
    });
  }

  function saveRegistration(db, reg) {
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(REG_STORE, 'readwrite');
      const store = tx.objectStore(REG_STORE);
      const req   = store.put(reg);
      req.onsuccess = () => resolve();
      req.onerror   = () => reject(req.error);
    });
  }

  function putOutbox(db, item) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(OUTBOX_STORE, 'readwrite');
      const store = tx.objectStore(OUTBOX_STORE);
      const req = store.put(item);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  function uuid() {
    return crypto.randomUUID ? crypto.randomUUID() :
      'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
        const r = (crypto.getRandomValues(new Uint8Array(1))[0] & 15);
        const v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
      });
  }

  async function markValidatedLocally() {
    try {
      const db = await openDb();
      const reg = await loadRegistration(db);
      if (reg) {
        const nowIso = new Date().toISOString();
        const updated = {
          ...reg,
          ...(payload?.updates || {}),
          status: 'validated',
          validatedAt: nowIso,
          validatedOnDevice: true,
        };
        await saveRegistration(db, updated);
      }
    } catch (err) {
      console.warn('Failed to update IndexedDB after confirm/queue', err);
    }
  }

  async function queueConfirmRequest(requestBody) {
    const db = await openDb();
    await putOutbox(db, {
      id: uuid(),
      type: 'confirm',
      status: 'pending',
      createdAt: new Date().toISOString(),
      programId: programId,
      registrationId: registrationId,
      referenceId: payload.referenceId,
      request: {
        url: '/api/registration/confirm',
        method: 'POST',
        body: requestBody,
      },
    });
  }

  // ---------- Render diffs ----------
  function renderChanges() {
    const updates  = payload.updates || {};
    const original = payload.original || {};

    const keys = Object.keys(updates);
    hasFieldChanges = keys.length > 0;

    const reasonLabel = document.querySelector('label[for="reason"]');

    if (!hasFieldChanges) {
      if (pageTitleEl) pageTitleEl.textContent = 'Validate registration';
      if (sectionTitleEl) sectionTitleEl.textContent = 'Ready to validate';
      if (sectionHelperEl) sectionHelperEl.textContent = 'No fields were changed. You can validate this registration.';

      changesTable.style.display = 'none';
      changesEmpty.hidden = true;

      if (reasonFieldWrap) reasonFieldWrap.style.display = 'none';
      if (reasonLabel) reasonLabel.textContent = 'Provide a reason for these changes (optional)';
      return;
    }

    if (pageTitleEl) pageTitleEl.textContent = 'Review changes';
    if (sectionTitleEl) sectionTitleEl.textContent = 'Changes to this registration';
    if (sectionHelperEl) sectionHelperEl.textContent = 'Please review edited fields:';

    changesTable.style.display = 'table';
    changesEmpty.hidden = true;

    if (reasonFieldWrap) reasonFieldWrap.style.display = '';
    if (reasonLabel) reasonLabel.textContent = 'Provide a reason for these changes*';

    const rows = [];
    for (const key of keys) {
      const beforeVal = original[key];
      const afterVal  = updates[key];

      const beforeStr = (beforeVal === null || beforeVal === undefined || beforeVal === '')
        ? '(empty)' : String(beforeVal);
      const afterStr  = (afterVal === null || afterVal === undefined || afterVal === '')
        ? '(empty)' : String(afterVal);

      rows.push(`
        <tr>
          <td class="review-field">${escapeHtml(labelFromKey(key))}</td>
          <td class="review-old">${escapeHtml(beforeStr)}</td>
          <td class="review-new">${escapeHtml(afterStr)}</td>
        </tr>
      `);
    }

    changesBody.innerHTML = rows.join('');
  }

  // ---------- Init payload ----------
  try {
    const raw = sessionStorage.getItem(REVIEW_KEY);
    if (!raw) {
      showError('Missing review data. Please go back and edit again.');
      return;
    }
    payload = JSON.parse(raw);
  } catch (err) {
    console.error('Failed to parse review payload', err);
    showError('Could not load review data.');
    return;
  }

  if (subtitleEl) subtitleEl.textContent = `Registration #${registrationId}`;

  renderChanges();

  // Back / Cancel → return to edit screen
  function goBackToEdit() {
    window.location.href =
      `/registration/${encodeURIComponent(programId)}/${encodeURIComponent(registrationId)}`;
  }

  if (backBtn) backBtn.addEventListener('click', goBackToEdit);
  if (cancelBtn) cancelBtn.addEventListener('click', goBackToEdit);

  // Reason character counter (0/500)
  function updateCounter() {
    if (!hasFieldChanges) return;
    const len = (reasonInput.value || '').length;
    if (counterEl) counterEl.textContent = `${len}/500`;
  }
  if (reasonInput) reasonInput.addEventListener('input', updateCounter);
  updateCounter();

  // ---------- Submit: Save + validate (or queue) ----------
  reviewForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    reviewError.hidden = true;

    const reason = hasFieldChanges ? (reasonInput.value || '').trim() : '';
    if (hasFieldChanges && !reason) {
      showError('Please provide a reason for these changes.');
      return;
    }

    submitBtn.disabled = true;
    submitBtn.textContent = navigator.onLine ? 'Saving…' : 'Saving offline…';

    const requestBody = {
      programId: programId,
      referenceId: payload.referenceId,
      updates: payload.updates || {},
      reason: reason || '',
    };

    // If offline right now, queue immediately
    if (!navigator.onLine) {
      try {
        await queueConfirmRequest(requestBody);
        await markValidatedLocally();

        sessionStorage.removeItem(REVIEW_KEY);
        sessionStorage.setItem('checkdroid_validation_success', 'queued');
        window.location.href = `/validate?program_id=${encodeURIComponent(programId)}`;
        return;
      } catch (err) {
        console.error(err);
        showError('Offline: could not queue this validation. Please try again.');
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = 'Save and validate';
      }
      return;
    }

    // Online path: try network; if it fails, fall back to queue
    try {
      const res = await fetch('/api/registration/confirm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });

      const ct = (res.headers.get('content-type') || '').toLowerCase();
      const isJson = ct.includes('application/json');
      const body = isJson ? await res.json().catch(() => ({})) : {};

      if (!res.ok || body.ok === false) {
        const msg = body.error || `Failed to save changes and validate in 121 (HTTP ${res.status}).`;
        throw new Error(msg);
      }

      await markValidatedLocally();

      sessionStorage.removeItem(REVIEW_KEY);
      sessionStorage.setItem('checkdroid_validation_success', '1');
      window.location.href = `/validate?program_id=${encodeURIComponent(programId)}`;

    } catch (err) {
      console.warn('Online confirm failed; queuing instead:', err);

      try {
        await queueConfirmRequest(requestBody);
        await markValidatedLocally();

        sessionStorage.removeItem(REVIEW_KEY);
        sessionStorage.setItem('checkdroid_validation_success', 'queued');
        window.location.href = `/validate?program_id=${encodeURIComponent(programId)}`;
        return;
      } catch (queueErr) {
        console.error(queueErr);
        showError((err && err.message) ? err.message : 'Could not complete validation.');
      }

    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Save and validate';
    }
  });
})();
</script>

{% endblock %}
