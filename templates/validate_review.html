{% extends "base.html" %}
{% block title %}Review changes – CheckDroid{% endblock %}

{% block content %}

<div class="review-page"
     data-program-id="{{ program_id }}"
     data-registration-id="{{ registration_id }}">

  <div class="review-card">

    <button type="button"
            class="reg-back-link"
            id="reviewBackBtn">
      ← Back to editing
    </button>

    <header class="review-header">
      <div>
        <!-- give the title an ID so we can change it when there are no changes -->
        <h1 id="reviewTitle" class="review-title">Review changes</h1>
        <div id="reviewSubtitle"
             class="review-subtitle">
          Registration #{{ registration_id }}
        </div>
      </div>
    </header>

    <section class="review-changes">
      <!-- also give these IDs so we can tweak copy dynamically -->
      <h2 id="reviewSectionTitle" class="review-section-title">Changes to this registration</h2>
      <p id="reviewHelper" class="review-helper">Please review edited fields:</p>
      <div id="changesEmpty" class="muted small" hidden>
        No field changes – you are only providing a reason.
      </div>

      <table class="review-table" id="changesTable">
        <thead>
          <tr>
            <th>Field</th>
            <th>Before</th>
            <th>After</th>
          </tr>
        </thead>
        <tbody id="changesBody">
          <!-- rows injected by JS -->
        </tbody>
      </table>
    </section>

    <form id="reviewForm" class="review-form" novalidate>
      <div id="reviewError" class="reg-error" hidden></div>

      <!-- WRAPPER NOW HAS AN ID SO WE CAN HIDE IT WHEN NO CHANGES -->
      <div id="reasonFieldWrap" class="reg-form-field">
        <label for="reason">Provide a reason for these changes*</label>
        <textarea id="reason"
                  name="reason"
                  maxlength="500"
                  rows="3"></textarea>
        <div id="reasonCounter" class="muted small"></div>
      </div>

      <div class="review-actions">
        <button type="button"
                class="btn btn-secondary"
                id="reviewCancelBtn">
          Cancel
        </button>
        <button type="submit"
                class="btn btn-primary"
                id="reviewSubmitBtn">
          Save and validate
        </button>
      </div>
    </form>
  </div>
</div>

<script>
(function () {
  const DB_NAME    = 'checkdroid';
  const DB_VERSION = 2;
  const REG_STORE  = 'registrations';

  const REVIEW_KEY = 'checkdroid_review_payload';

  const root = document.querySelector('.review-page');
  if (!root) return;

function parseIdsFromQueryOrDom(rootEl) {
  const dsPid = parseInt(rootEl?.dataset?.programId || '', 10) || null;
  const dsRid = parseInt(rootEl?.dataset?.registrationId || '', 10) || null;

  const qs = new URLSearchParams(window.location.search);
  const qsPid = parseInt(qs.get('program_id') || '', 10) || null;
  const qsRid = parseInt(qs.get('registration_id') || '', 10) || null;

  return {
    programId: dsPid || qsPid,
    registrationId: dsRid || qsRid,
  };
}

const ids = parseIdsFromQueryOrDom(root);
const programId = ids.programId;
const registrationId = ids.registrationId;

if (!programId || !registrationId) {
  showError('Missing program/registration ID. Please go back and open the review step again.');
  return;
}

// Keep dataset consistent for downstream code
root.dataset.programId = String(programId);
root.dataset.registrationId = String(registrationId);

  const backBtn      = document.getElementById('reviewBackBtn');
  const changesTable = document.getElementById('changesTable');
  const changesBody  = document.getElementById('changesBody');
  const changesEmpty = document.getElementById('changesEmpty');
  const reviewForm   = document.getElementById('reviewForm');
  const reviewError  = document.getElementById('reviewError');
  const reasonInput  = document.getElementById('reason');
  const cancelBtn    = document.getElementById('reviewCancelBtn');
  const submitBtn    = document.getElementById('reviewSubmitBtn');
  const subtitleEl   = document.getElementById('reviewSubtitle');
  const counterEl    = document.getElementById('reasonCounter');
  const reasonFieldWrap = document.getElementById('reasonFieldWrap');

  // NEW: title + section elements so we can change copy for no-changes case
  const pageTitleEl       = document.getElementById('reviewTitle');
  const sectionTitleEl    = document.getElementById('reviewSectionTitle');
  const sectionHelperEl   = document.getElementById('reviewHelper');

  let payload = null;
  let hasFieldChanges = false;

  function escapeHtml(str) {
    return String(str ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function labelFromKey(key) {
    return key
      .replace(/_/g, ' ')
      .replace(/([a-z])([A-Z])/g, '$1 $2')
      .replace(/\s+/g, ' ')
      .trim()
      .replace(/^./, c => c.toUpperCase());
  }

  function showError(msg) {
    reviewError.textContent = msg;
    reviewError.hidden = false;
  }

  // ---------- IndexedDB helpers ----------
  function openDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onsuccess = () => resolve(req.result);
      req.onerror   = () => reject(req.error);
    });
  }

  function loadRegistration(db) {
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(REG_STORE, 'readonly');
      const store = tx.objectStore(REG_STORE);
      const req   = store.get(registrationId);

      req.onsuccess = () => resolve(req.result || null);
      req.onerror   = () => reject(req.error);
    });
  }

  function saveRegistration(db, reg) {
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(REG_STORE, 'readwrite');
      const store = tx.objectStore(REG_STORE);
      const req   = store.put(reg);
      req.onsuccess = () => resolve();
      req.onerror   = () => reject(req.error);
    });
  }

  // ---------- Render diffs ----------
  function renderChanges() {
    const updates  = payload.updates || {};
    const original = payload.original || {};

    const keys = Object.keys(updates);
    hasFieldChanges = keys.length > 0;

    const reasonLabel = document.querySelector('label[for="reason"]');

    if (!hasFieldChanges) {
      // No field changes: adjust copy so page reads as a simple validation step
      if (pageTitleEl) {
        pageTitleEl.textContent = 'Validate registration';
      }
      if (sectionTitleEl) {
        sectionTitleEl.textContent = 'Ready to validate';
      }
      if (sectionHelperEl) {
        sectionHelperEl.textContent = 'No fields were changed. You can validate this registration.';
      }

      // Hide table + diff rows
      changesTable.style.display = 'none';
      // You can either show or hide this helper; here we keep a simple note:
      changesEmpty.hidden = true;

      // Hide reason box entirely
      if (reasonFieldWrap) {
        reasonFieldWrap.style.display = 'none';
      }
      if (reasonLabel) {
        reasonLabel.textContent = 'Provide a reason for these changes (optional)';
      }
      return;
    }

    // There ARE changes: keep original "review" copy
    if (pageTitleEl) {
      pageTitleEl.textContent = 'Review changes';
    }
    if (sectionTitleEl) {
      sectionTitleEl.textContent = 'Changes to this registration';
    }
    if (sectionHelperEl) {
      sectionHelperEl.textContent = 'Please review edited fields:';
    }

    changesTable.style.display = 'table';
    changesEmpty.hidden = true;

    if (reasonFieldWrap) {
      reasonFieldWrap.style.display = '';
    }
    if (reasonLabel) {
      reasonLabel.textContent = 'Provide a reason for these changes*';
    }

    const rows = [];
    for (const key of keys) {
      const beforeVal = original[key];
      const afterVal  = updates[key];

      const beforeStr = beforeVal === null || beforeVal === undefined || beforeVal === ''
        ? '(empty)'
        : String(beforeVal);
      const afterStr  = afterVal === null || afterVal === undefined || afterVal === ''
        ? '(empty)'
        : String(afterVal);

      rows.push(`
        <tr>
          <td class="review-field">${escapeHtml(labelFromKey(key))}</td>
          <td class="review-old">${escapeHtml(beforeStr)}</td>
          <td class="review-new">${escapeHtml(afterStr)}</td>
        </tr>
      `);
    }

    changesBody.innerHTML = rows.join('');
  }

  // ---------- Init payload ----------
  try {
    const raw = sessionStorage.getItem(REVIEW_KEY);
    if (!raw) {
      showError('Missing review data. Please go back and edit again.');
      return;
    }
    payload = JSON.parse(raw);
  } catch (err) {
    console.error('Failed to parse review payload', err);
    showError('Could not load review data.');
    return;
  }

  if (subtitleEl) {
    subtitleEl.textContent = `Registration #${registrationId}`;
  }

  renderChanges();

  // Back / Cancel → return to edit screen
  function goBackToEdit() {
    window.location.href =
      `/registration/${encodeURIComponent(programId)}/${encodeURIComponent(registrationId)}`;
  }

  backBtn.addEventListener('click', goBackToEdit);
  cancelBtn.addEventListener('click', goBackToEdit);

  // Reason character counter (0/500)
  function updateCounter() {
    if (!hasFieldChanges) return;  // no reason box, no counter needed
    const len = (reasonInput.value || '').length;
    if (counterEl) counterEl.textContent = `${len}/500`;
  }
  reasonInput.addEventListener('input', updateCounter);
  updateCounter();

  // ---------- Submit: Save + validate ----------
  reviewForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    reviewError.hidden = true;

    // Only require a reason if there are actual field changes
    const reason = hasFieldChanges ? (reasonInput.value || '').trim() : '';

    if (hasFieldChanges && !reason) {
      showError('Please provide a reason for these changes.');
      return;
    }

    submitBtn.disabled = true;
    submitBtn.textContent = 'Saving…';

    try {
      const res = await fetch('/api/registration/confirm', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          programId: programId,
          referenceId: payload.referenceId,
          updates: payload.updates || {},
          reason: reason,
        }),
      });

      const body = await res.json().catch(() => ({}));
      if (!res.ok || body.ok === false) {
        const msg = body.error || 'Failed to save changes and validate in 121.';
        throw new Error(msg);
      }

      // ---- Update offline cache: apply updates + mark validated today ----
      try {
        const db = await openDb();
        const reg = await loadRegistration(db);
        if (reg) {
          const nowIso = new Date().toISOString();
          const updated = {
            ...reg,
            ...(payload.updates || {}),
            status: 'validated',
            validatedAt: nowIso,
            validatedOnDevice: true,
          };
          await saveRegistration(db, updated);
        }
      } catch (err) {
        console.warn('Failed to update IndexedDB after confirm', err);
      }

      // Flag success for next page & redirect
      sessionStorage.removeItem(REVIEW_KEY);
      sessionStorage.setItem('checkdroid_validation_success', '1');
      window.location.href = `/validate?program_id=${encodeURIComponent(programId)}`;

    } catch (err) {
      console.error(err);
      showError(err.message || 'Could not complete validation.');
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Save and validate';
    }
  });
})();
</script>

{% endblock %}
