{% extends "base.html" %}
{% block title %}{{ program_title }} ‚Äì CheckDroid{% endblock %}

{% block content %}
<div class="validate-page" data-program-id="{{ program_id }}">

  <!-- Header: program name + stats -->
  <section class="validate-header">
    <div class="validate-header-top">
      <h1 class="validate-title">{{ program_title }}</h1>
    </div>

    <div class="validate-subrow">
      <div class="sync-status">
        <span class="sync-status-icon"></span>
        <span class="sync-status-text" id="syncStatusText">
          Last synced just now
        </span>
      </div>

      <div class="validate-stats">
        <div class="stat-chip">
          <div class="stat-chip-value" id="statValidatedToday">0</div>
          <div class="stat-chip-label">Validated on this device today</div>
        </div>
        <div class="stat-chip">
          <div class="stat-chip-value" id="statSyncedCount">0</div>
          <div class="stat-chip-label">Registrations synced to device</div>
        </div>
      </div>
    </div>

    <div class="validate-search">
      <label class="validate-search-label" for="searchInput">
        Search registrations to validate
      </label>
      <div class="validate-search-input-wrap">
        <span class="validate-search-icon">üîç</span>
        <input
          id="searchInput"
          type="text"
          class="validate-search-input"
          placeholder="Search by name, phone, or reference ID"
        >
      </div>
    </div>
  </section>

  <!-- List of registrations -->
  <section class="validate-list" id="registrationList">
    <!-- cards injected by JS -->
  </section>
</div>
<script>
(function () {
  // --- one-shot success banner after validation ---
  const flag = sessionStorage.getItem('checkdroid_validation_success');
  if (flag) {
    sessionStorage.removeItem('checkdroid_validation_success');
    const root = document.querySelector('.validate-page') || document.querySelector('.page');
    if (root) {
      const banner = document.createElement('div');
      banner.className = 'validate-success-banner';
      banner.textContent = 'Registration successfully validated.';
      root.prepend(banner);
    }
  }

  const DB_NAME    = 'checkdroid';
  const DB_VERSION = 2;
  const REG_STORE  = 'registrations';
  const DEC_STORE  = 'decisions';

  const pageRoot = document.querySelector('.validate-page');
  if (!pageRoot) return;

  // ---------- NEW: programId + title fallbacks for offline shell ----------
  function getProgramIdFromUrlOrDom(rootEl) {
    // 1) dataset (online render)
    const ds = parseInt(rootEl?.dataset?.programId || "", 10);
    if (ds) return ds;

    // 2) query string (?program_id=123) (offline shell + navigation)
    const qs = parseInt(new URLSearchParams(window.location.search).get("program_id") || "", 10);
    if (qs) return qs;

    return null;
  }

  function getCachedProgramTitle(programId) {
    try {
      const raw = localStorage.getItem("checkdroid_programs");
      if (!raw) return null;
      const arr = JSON.parse(raw);
      const hit = arr.find(p => Number(p.id) === Number(programId));
      return hit?.title || null;
    } catch {
      return null;
    }
  }

  const programId = getProgramIdFromUrlOrDom(pageRoot);

  if (!programId) {
    const listEl = document.getElementById('registrationList');
    const syncStatusText = document.getElementById('syncStatusText');
    if (listEl) listEl.innerHTML = '<div class="muted small">Missing program ID. Open this program once online, then retry offline.</div>';
    if (syncStatusText) syncStatusText.textContent = 'Program ID missing';
    return;
  }

  // keep dataset consistent for the rest of this script
  pageRoot.dataset.programId = String(programId);

  // Set program title in header if Jinja rendered it empty (offline shell)
  const cachedTitle = getCachedProgramTitle(programId);
  const titleEl = document.querySelector(".validate-title");
  if (titleEl) {
    const current = (titleEl.textContent || "").trim();
    if (!current) {
      titleEl.textContent = cachedTitle || `Program ${programId}`;
    }
  }
  if (cachedTitle) {
    document.title = `${cachedTitle} ‚Äì CheckDroid`;
  } else if (!document.title || document.title.trim() === "CheckDroid") {
    document.title = `Program ${programId} ‚Äì CheckDroid`;
  }
  // ----------------------------------------------------------------------

  const listEl             = document.getElementById('registrationList');
  const searchInput        = document.getElementById('searchInput');
  const statSynced         = document.getElementById('statSyncedCount');
  const statValidatedToday = document.getElementById('statValidatedToday');
  const syncStatusText     = document.getElementById('syncStatusText');

  let allRegistrations = [];
  let decisionsById    = new Map();

  // ---------- helpers ----------
  function safeEscape(str) {
    return String(str ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function decisionFor(regId) {
    return decisionsById.get(regId) || null;
  }

  // ---------- IndexedDB ----------
  function openDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);

      req.onupgradeneeded = (event) => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains(REG_STORE)) {
          const regStore = db.createObjectStore(REG_STORE, { keyPath: 'id' });
          regStore.createIndex('by_program', 'programId', { unique: false });
        }

        if (!db.objectStoreNames.contains(DEC_STORE)) {
          const decStore = db.createObjectStore(DEC_STORE, { keyPath: 'id' });
          decStore.createIndex('by_program', 'programId', { unique: false });
        }
      };

      req.onsuccess = () => resolve(req.result);
      req.onerror   = () => reject(req.error);
    });
  }

  function loadRegistrations(db) {
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(REG_STORE, 'readonly');
      const store = tx.objectStore(REG_STORE);
      const index = store.index('by_program');
      const req   = index.getAll(IDBKeyRange.only(programId));

      req.onsuccess = () => resolve(req.result || []);
      req.onerror   = () => reject(req.error);
    });
  }

  function loadDecisions(db) {
    if (!db.objectStoreNames.contains(DEC_STORE)) {
      return Promise.resolve([]);
    }
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(DEC_STORE, 'readonly');
      const store = tx.objectStore(DEC_STORE);

      let req;
      if (store.indexNames.contains('by_program')) {
        const index = store.index('by_program');
        req = index.getAll(IDBKeyRange.only(programId));
      } else {
        req = store.getAll();
      }

      req.onsuccess = () => {
        const all = req.result || [];
        if (store.indexNames.contains('by_program')) {
          resolve(all);
        } else {
          resolve(all.filter(d => d.programId === programId));
        }
      };
      req.onerror = () => reject(req.error);
    });
  }

  // ---------- Rendering ----------
  function renderList(filter) {
    const q     = (filter || '').trim().toLowerCase();
    const today = new Date().toISOString().slice(0, 10);

    let validatedTodayCount = 0;
    const out = [];

    for (const reg of allRegistrations) {
      const dec = decisionFor(reg.id);

      // Base status: 121 status, overridden by any local decision
      let status = 'new';
      if (reg.status) {
        status = String(reg.status).toLowerCase();
      }
      if (dec && dec.status) {
        status = String(dec.status).toLowerCase();
      }

      // Determine "validated on this device today"
      let validatedToday = false;

      // 1) If we have a decision with today's date
      if (
        dec &&
        String(dec.status).toLowerCase() === 'validated' &&
        dec.date &&
        String(dec.date).startsWith(today)
      ) {
        validatedToday = true;
      }
      // 2) Fallback: the registration itself carries validatedAt/validatedOnDevice
      else if (
        String(status).toLowerCase() === 'validated' &&
        reg.validatedOnDevice &&
        reg.validatedAt &&
        String(reg.validatedAt).startsWith(today)
      ) {
        validatedToday = true;
      }

      if (validatedToday) {
        validatedTodayCount += 1;
      }

      // Text search
      if (q) {
        const haystack = [
          reg.fullName || reg.name || '',
          reg.phoneNumber || '',
          reg.referenceId || String(reg.id || '')
        ].join(' ').toLowerCase();

        if (!haystack.includes(q)) continue;
      }

      const name     = reg.fullName || reg.name || '(no name)';
      const phone    = reg.phoneNumber || '';
      const ref      = reg.referenceId || '';
      const regTitle = `Registration #${reg.id}`;

      const badgeText  = status === 'validated' ? 'Validated' : 'New';
      const badgeClass = status === 'validated'
        ? 'reg-badge reg-badge-validated'
        : 'reg-badge reg-badge-new';

      out.push(`
        <article class="reg-card" data-id="${reg.id}">
          <div class="reg-main">
            <div class="reg-header">
              <div class="reg-title">${safeEscape(regTitle)}</div>
              <span class="${badgeClass}">${badgeText}</span>
            </div>
            <div class="reg-body">
              <div><strong>Name:</strong> ${safeEscape(name)}</div>
              ${phone ? `<div><strong>Phone:</strong> ${safeEscape(phone)}</div>` : ''}
              ${ref   ? `<div><strong>ID number:</strong> ${safeEscape(ref)}</div>` : ''}
            </div>
          </div>
        </article>
      `);
    }

    listEl.innerHTML = out.join('') || `
      <div class="muted small">No registrations found for this program.</div>
    `;

    // click ‚Üí detail page
    listEl.querySelectorAll('.reg-card').forEach(card => {
      const regId = Number(card.dataset.id);
      card.addEventListener('click', () => {
        window.location.href =
          `/registration/${encodeURIComponent(programId)}/${encodeURIComponent(regId)}`;
      });
    });

    // update counters
    statSynced.textContent         = allRegistrations.length;
    statValidatedToday.textContent = validatedTodayCount;
  }

  // ---------- Init ----------
  openDb()
    .then(async (db) => {
      const [regs, decs] = await Promise.all([
        loadRegistrations(db),
        loadDecisions(db),
      ]);

      allRegistrations = regs || [];
      decisionsById    = new Map();
      for (const d of decs) {
        decisionsById.set(d.id, d);
      }

      renderList('');
      syncStatusText.textContent = 'Last synced just now';
    })
    .catch((err) => {
      console.error('Failed to load registrations from IndexedDB', err);
      listEl.innerHTML           = '<div class="muted small">Could not load offline data.</div>';
      syncStatusText.textContent = 'Offline cache unavailable';
    });

  // live search
  searchInput.addEventListener('input', (e) => {
    renderList(e.target.value || '');
  });
})();
</script>


{% endblock %}
