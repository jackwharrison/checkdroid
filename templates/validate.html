{% extends "base.html" %}
{% block title %}{{ program_title }} ‚Äì CheckDroid{% endblock %}

{% block content %}
<div class="validate-page" data-program-id="{{ program_id }}">
  <div style="margin: 8px 0 20px 0;">
    <button
      class="btn btn-secondary"
      type="button"
      onclick="window.location.href='{{ url_for('index') }}'"
      style="padding: 6px 16px; font-size: 1rem;"
    >
      ‚Üê Back to home
    </button>
  </div>

  <!-- Header: program name + stats -->
  <section class="validate-header">
    <div class="validate-header-top">
      <h1 class="validate-title">{{ program_title }}</h1>
    </div>


    
    <div class="validate-subrow">
      <div class="sync-status">
        <span class="sync-status-icon"></span>
        <span class="sync-status-text" id="syncStatusText">
          Last synced just now
        </span>
      </div>

      <div class="validate-stats">
        <div class="stat-chip">
          <div class="stat-chip-value" id="statValidatedToday">0</div>
          <div class="stat-chip-label">Validated on this device today</div>
        </div>
        <div class="stat-chip">
          <div class="stat-chip-value" id="statSyncedCount">0</div>
          <div class="stat-chip-label">Registrations synced to device</div>
        </div>
      </div>
    </div>

    <div class="validate-search">
      <label class="validate-search-label" for="searchInput">
        Search registrations to validate
      </label>
      <div class="validate-search-input-wrap">
        <span class="validate-search-icon">üîç</span>
        <input
          id="searchInput"
          type="text"
          class="validate-search-input"
          placeholder="Search by name, phone, or reference ID"
        >
      </div>
    </div>
  </section>

  <!-- List of registrations -->
  <section class="validate-list" id="registrationList">
    <!-- cards injected by JS -->
  </section>
</div>
<script>
(function () {
  // --- one-shot success / queued banner after validation ---
  const flag = sessionStorage.getItem('checkdroid_validation_success');
  if (flag) {
    sessionStorage.removeItem('checkdroid_validation_success');
    const root = document.querySelector('.validate-page') || document.querySelector('.page');
    if (root) {
      const banner = document.createElement('div');
      banner.className = 'validate-success-banner';
      banner.textContent =
        (flag === 'queued')
          ? 'Saved offline. This validation will sync when you are back online.'
          : 'Registration successfully validated.';
      root.prepend(banner);
    }
  }

  const DB_NAME      = 'checkdroid';
  const DB_VERSION   = 3; // includes outbox
  const REG_STORE    = 'registrations';
  const DEC_STORE    = 'decisions';
  const OUTBOX_STORE = 'outbox';

  const pageRoot = document.querySelector('.validate-page');
  if (!pageRoot) return;

  // ---------- programId + title fallbacks for offline shell ----------
  function getProgramIdFromUrlOrDom(rootEl) {
    const ds = parseInt(rootEl?.dataset?.programId || "", 10);
    if (ds) return ds;

    const qs = parseInt(new URLSearchParams(window.location.search).get("program_id") || "", 10);
    if (qs) return qs;

    return null;
  }

  function getCachedProgramTitle(programId) {
    try {
      const raw = localStorage.getItem("checkdroid_programs");
      if (!raw) return null;
      const arr = JSON.parse(raw);
      const hit = arr.find(p => Number(p.id) === Number(programId));
      return hit?.title || null;
    } catch {
      return null;
    }
  }

  const programId = getProgramIdFromUrlOrDom(pageRoot);

  if (!programId) {
    const listEl = document.getElementById('registrationList');
    const syncStatusText = document.getElementById('syncStatusText');
    if (listEl) listEl.innerHTML = '<div class="muted small">Missing program ID. Open this program once online, then retry offline.</div>';
    if (syncStatusText) syncStatusText.textContent = 'Program ID missing';
    return;
  }

  // keep dataset consistent for the rest of this script
  pageRoot.dataset.programId = String(programId);

  // Set program title in header if Jinja rendered it empty (offline shell)
  const cachedTitle = getCachedProgramTitle(programId);
  const titleEl = document.querySelector(".validate-title");
  if (titleEl) {
    const current = (titleEl.textContent || "").trim();
    if (!current) {
      titleEl.textContent = cachedTitle || `Program ${programId}`;
    }
  }
  if (cachedTitle) {
    document.title = `${cachedTitle} ‚Äì CheckDroid`;
  } else if (!document.title || document.title.trim() === "CheckDroid") {
    document.title = `Program ${programId} ‚Äì CheckDroid`;
  }
  // ------------------------------------------------------------------

  const listEl             = document.getElementById('registrationList');
  const searchInput        = document.getElementById('searchInput');
  const statSynced         = document.getElementById('statSyncedCount');
  const statValidatedToday = document.getElementById('statValidatedToday');
  const syncStatusText     = document.getElementById('syncStatusText');

  let allRegistrations = [];
  let decisionsById    = new Map();

  // ---------- helpers ----------
  function safeEscape(str) {
    return String(str ?? '')
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function decisionFor(regId) {
    return decisionsById.get(regId) || null;
  }

  // ---------- IndexedDB ----------
  function openDb() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);

      req.onupgradeneeded = (event) => {
        const db = event.target.result;

        if (!db.objectStoreNames.contains(REG_STORE)) {
          const regStore = db.createObjectStore(REG_STORE, { keyPath: 'id' });
          regStore.createIndex('by_program', 'programId', { unique: false });
        }

        if (!db.objectStoreNames.contains(DEC_STORE)) {
          const decStore = db.createObjectStore(DEC_STORE, { keyPath: 'id' });
          decStore.createIndex('by_program', 'programId', { unique: false });
        }

        if (!db.objectStoreNames.contains(OUTBOX_STORE)) {
          const out = db.createObjectStore(OUTBOX_STORE, { keyPath: 'id' }); // uuid
          out.createIndex('by_status', 'status', { unique: false });
          out.createIndex('by_created', 'createdAt', { unique: false });
          out.createIndex('by_reg', 'registrationId', { unique: false });
          out.createIndex('by_program', 'programId', { unique: false });
        }
      };

      req.onsuccess = () => resolve(req.result);
      req.onerror   = () => reject(req.error);
    });
  }

  function loadRegistrations(db) {
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(REG_STORE, 'readonly');
      const store = tx.objectStore(REG_STORE);
      const index = store.index('by_program');
      const req   = index.getAll(IDBKeyRange.only(programId));

      req.onsuccess = () => resolve(req.result || []);
      req.onerror   = () => reject(req.error);
    });
  }

  function loadDecisions(db) {
    if (!db.objectStoreNames.contains(DEC_STORE)) {
      return Promise.resolve([]);
    }
    return new Promise((resolve, reject) => {
      const tx    = db.transaction(DEC_STORE, 'readonly');
      const store = tx.objectStore(DEC_STORE);

      let req;
      if (store.indexNames.contains('by_program')) {
        const index = store.index('by_program');
        req = index.getAll(IDBKeyRange.only(programId));
      } else {
        req = store.getAll();
      }

      req.onsuccess = () => {
        const all = req.result || [];
        if (store.indexNames.contains('by_program')) {
          resolve(all);
        } else {
          resolve(all.filter(d => d.programId === programId));
        }
      };
      req.onerror = () => reject(req.error);
    });
  }

  // ---------- Outbox helpers ----------
  function uuidv4() {
    // browser-safe UUID
    if (crypto?.randomUUID) return crypto.randomUUID();
    const a = crypto.getRandomValues(new Uint8Array(16));
    a[6] = (a[6] & 0x0f) | 0x40;
    a[8] = (a[8] & 0x3f) | 0x80;
    const hex = [...a].map(b => b.toString(16).padStart(2, '0')).join('');
    return `${hex.slice(0,8)}-${hex.slice(8,12)}-${hex.slice(12,16)}-${hex.slice(16,20)}-${hex.slice(20)}`;
  }

  function getOutboxByProgram(db, pid) {
    if (!db.objectStoreNames.contains(OUTBOX_STORE)) return Promise.resolve([]);
    return new Promise((resolve, reject) => {
      const tx = db.transaction(OUTBOX_STORE, 'readonly');
      const store = tx.objectStore(OUTBOX_STORE);
      const idx = store.index('by_program');
      const req = idx.getAll(IDBKeyRange.only(pid));
      req.onsuccess = () => resolve(req.result || []);
      req.onerror = () => reject(req.error);
    });
  }

  function putOutbox(db, item) {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(OUTBOX_STORE, 'readwrite');
      const store = tx.objectStore(OUTBOX_STORE);
      const req = store.put(item);
      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  }

  function countOutbox(items) {
    return {
      pending: items.filter(x => x.status === 'pending').length,
      failed:  items.filter(x => x.status === 'failed').length,
      sent:    items.filter(x => x.status === 'sent').length,
    };
  }

  // Create an outbox item (use this from validate_review when offline)
  async function queueConfirmAction(body, registrationIdGuess) {
    const db = await openDb();
    const item = {
      id: uuidv4(),
      type: 'confirm',
      status: 'pending',
      programId: Number(body.programId),
      registrationId: Number(registrationIdGuess || 0),
      createdAt: new Date().toISOString(),
      request: {
        url: '/api/registration/confirm',
        method: 'POST',
        body: body,
      },
      error: null,
    };
    await putOutbox(db, item);
    return item;
  }

  let outboxFlushInProgress = false;

  async function flushOutbox() {
    if (!navigator.onLine) return { sent: 0, failed: 0, pending: 0, totalPending: 0, totalFailed: 0 };
    if (outboxFlushInProgress) return { sent: 0, failed: 0, pending: 0, totalPending: 0, totalFailed: 0 };

    outboxFlushInProgress = true;

    try {
      const db = await openDb();
      const allForProgram = await getOutboxByProgram(db, programId);

      const pendingItems = allForProgram
        .filter(x => x.status === 'pending' && x.type === 'confirm')
        .sort((a, b) => String(a.createdAt).localeCompare(String(b.createdAt)));

      let sentNow = 0;
      let failedNow = 0;

      for (const item of pendingItems) {
        try {
          const res = await fetch(item.request.url, {
            method: item.request.method || 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(item.request.body || {}),
          });

          // auth issues likely mean session is gone or redirected
          if (res.status === 401 || res.status === 403) {
            const err = new Error('Session expired. Please log in again.');
            err.permanent = true;
            throw err;
          }

          const ct = (res.headers.get('content-type') || '').toLowerCase();
          const isJson = ct.includes('application/json');
          if (!isJson) {
            const err = new Error('Unexpected response (login page returned). Please log in again.');
            err.permanent = true;
            throw err;
          }

          const body = await res.json().catch(() => ({}));
          if (!res.ok || body.ok === false) {
            const msg = body?.error || `HTTP ${res.status}`;
            const err = new Error(msg);
            // 4xx usually permanent; 5xx transient
            err.permanent = (res.status >= 400 && res.status < 500);
            throw err;
          }

          await putOutbox(db, {
            ...item,
            status: 'sent',
            sentAt: new Date().toISOString(),
            error: null,
          });
          sentNow += 1;

        } catch (err) {
          const permanent = !!err?.permanent;

          if (permanent) {
            await putOutbox(db, {
              ...item,
              status: 'failed',
              failedAt: new Date().toISOString(),
              error: String(err?.message || err),
            });
            failedNow += 1;
          } else {
            // transient: keep pending, retry later
            await putOutbox(db, {
              ...item,
              status: 'pending',
              lastErrorAt: new Date().toISOString(),
              error: String(err?.message || err),
            });
          }
        }
      }

      const after = await getOutboxByProgram(db, programId);
      const counts = countOutbox(after);

      return {
        sent: sentNow,
        failed: failedNow,
        pending: pendingItems.length,
        totalPending: counts.pending,
        totalFailed: counts.failed,
      };

    } finally {
      outboxFlushInProgress = false;
    }
  }

  // Expose queue helper for validate_review page to call when offline
  window.CheckDroidQueue = {
    queueConfirmAction,
    flushOutbox,
  };

  // ---------- Rendering ----------
  function renderList(filter) {
    const q     = (filter || '').trim().toLowerCase();
    const today = new Date().toISOString().slice(0, 10);

    let validatedTodayCount = 0;
    const out = [];

    for (const reg of allRegistrations) {
      const dec = decisionFor(reg.id);

      // Base status: 121 status, overridden by any local decision
      let status = 'new';
      if (reg.status) status = String(reg.status).toLowerCase();
      if (dec && dec.status) status = String(dec.status).toLowerCase();

      // Determine "validated on this device today"
      let validatedToday = false;

      if (
        dec &&
        String(dec.status).toLowerCase() === 'validated' &&
        dec.date &&
        String(dec.date).startsWith(today)
      ) {
        validatedToday = true;
      } else if (
        String(status).toLowerCase() === 'validated' &&
        reg.validatedOnDevice &&
        reg.validatedAt &&
        String(reg.validatedAt).startsWith(today)
      ) {
        validatedToday = true;
      }

      if (validatedToday) validatedTodayCount += 1;

      // Text search
      if (q) {
        const haystack = [
          reg.fullName || reg.name || '',
          reg.phoneNumber || '',
          reg.referenceId || String(reg.id || '')
        ].join(' ').toLowerCase();

        if (!haystack.includes(q)) continue;
      }

      const name     = reg.fullName || reg.name || '(no name)';
      const phone    = reg.phoneNumber || '';
      const ref      = reg.referenceId || '';
      const regTitle = `Registration #${reg.id}`;

      const badgeText  = status === 'validated' ? 'Validated' : 'New';
      const badgeClass = status === 'validated'
        ? 'reg-badge reg-badge-validated'
        : 'reg-badge reg-badge-new';

      out.push(`
        <article class="reg-card" data-id="${reg.id}">
          <div class="reg-main">
            <div class="reg-header">
              <div class="reg-title">${safeEscape(regTitle)}</div>
              <span class="${badgeClass}">${badgeText}</span>
            </div>
            <div class="reg-body">
              <div><strong>Name:</strong> ${safeEscape(name)}</div>
              ${phone ? `<div><strong>Phone:</strong> ${safeEscape(phone)}</div>` : ''}
              ${ref   ? `<div><strong>ID number:</strong> ${safeEscape(ref)}</div>` : ''}
            </div>
          </div>
        </article>
      `);
    }

    listEl.innerHTML = out.join('') || `
      <div class="muted small">No registrations found for this program.</div>
    `;

    // click ‚Üí detail page
    listEl.querySelectorAll('.reg-card').forEach(card => {
      const regId = Number(card.dataset.id);
      card.addEventListener('click', () => {
        window.location.href =
          `/registration/${encodeURIComponent(programId)}/${encodeURIComponent(regId)}`;
      });
    });

    // update counters
    statSynced.textContent         = allRegistrations.length;
    statValidatedToday.textContent = validatedTodayCount;
  }

  async function init() {
    try {
      const db = await openDb();
      const [regs, decs] = await Promise.all([
        loadRegistrations(db),
        loadDecisions(db),
      ]);

      allRegistrations = regs || [];
      decisionsById = new Map();
      for (const d of decs) decisionsById.set(d.id, d);

      renderList('');

      // Status line: show pending/failed when offline; flush when online
      if (navigator.onLine) {
        const r = await flushOutbox();
        syncStatusText.textContent =
          (r.pending > 0)
            ? `Online. Synced ${r.sent}. Pending ${r.totalPending}. Failed ${r.totalFailed}.`
            : 'Online.';
      } else {
        const items = await getOutboxByProgram(db, programId);
        const c = countOutbox(items);
        syncStatusText.textContent = `Offline mode. Pending ${c.pending}. Failed ${c.failed}.`;
      }

    } catch (err) {
      console.error('Failed to load registrations from IndexedDB', err);
      listEl.innerHTML = '<div class="muted small">Could not load offline data.</div>';
      syncStatusText.textContent = 'Offline cache unavailable';
    }
  }

  init();

  window.addEventListener('online', async () => {
    try {
      const r = await flushOutbox();
      syncStatusText.textContent =
        `Back online. Synced ${r.sent}. Pending ${r.totalPending}. Failed ${r.totalFailed}.`;
    } catch (err) {
      console.warn('Outbox flush failed', err);
      syncStatusText.textContent = 'Back online, but sync failed.';
    }
  });

  window.addEventListener('offline', async () => {
    try {
      const db = await openDb();
      const items = await getOutboxByProgram(db, programId);
      const c = countOutbox(items);
      syncStatusText.textContent = `Offline mode. Pending ${c.pending}. Failed ${c.failed}.`;
    } catch {
      syncStatusText.textContent = 'Offline mode.';
    }
  });

  // live search
  if (searchInput) {
    searchInput.addEventListener('input', (e) => {
      renderList(e.target.value || '');
    });
  }
})();
</script>

{% endblock %}
